<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Car Game - Sound & Audio Update</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', sans-serif; color: white; }
        #game-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
        #ui-layer, #results-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 10;
            transition: opacity 0.5s ease;
        }
        .hidden { display: none !important; opacity: 0; pointer-events: none; }
        
        /* HUD */
        .hud {
            position: absolute; top: 20px; left: 20px; font-size: 24px; font-weight: bold;
            text-shadow: 2px 2px 0 #000; z-index: 5; pointer-events: none;
        }
        h1 { color: #00d2d3; margin-bottom: 10px; text-align: center; }
        .grid { display: flex; gap: 20px; margin-bottom: 30px; }
        
        /* Selection Cards */
        .card {
            background: #222; padding: 20px; border-radius: 8px; cursor: pointer;
            text-align: center; border: 3px solid transparent; transition: 0.2s; min-width: 120px;
        }
        .card:hover { transform: translateY(-5px); }
        .card.selected { border-color: #00d2d3; background: #333; }
        
        /* Buttons */
        button {
            padding: 15px 40px; font-size: 20px; font-weight: bold; background: #00d2d3;
            color: black; border: none; border-radius: 5px; cursor: pointer; transition: 0.2s;
        }
        button:hover { background: #48dbfb; transform: scale(1.05); }
        .controls { margin-top: 15px; color: #aaa; }
        
        /* Boost Effects */
        #speed-lines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 50px rgba(0, 255, 255, 0); transition: 0.3s; pointer-events: none; z-index: 2;
        }
        .boosting { box-shadow: inset 0 0 100px rgba(0, 255, 255, 0.6) !important; }

        /* Countdown */
        #countdown-display, #finish-display {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 150px; font-weight: bold; color: #ffeb3b; 
            text-shadow: 4px 4px 15px rgba(0,0,0,0.8); z-index: 20; pointer-events: none;
            transition: 0.2s transform;
        }
        #finish-display { font-size: 100px; color: #2ed573; text-align: center; width: 100%; }
        .pop { transform: translate(-50%, -50%) scale(1.2) !important; }

        /* Results Screen */
        .results-box {
            background: #222; padding: 40px; border-radius: 12px;
            border: 2px solid #00d2d3; text-align: center; min-width: 400px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }
        .results-box h2 { margin-top: 0; color: #ffeb3b; font-size: 36px; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 30px; font-size: 20px; }
        th, td { padding: 12px; border-bottom: 1px solid #444; }
        th { color: #aaa; font-size: 16px; text-transform: uppercase; }
        .player-row { background: rgba(0, 210, 211, 0.2); font-weight: bold; color: #00d2d3; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="game-container"></div>
<div id="speed-lines"></div>

<div id="countdown-display" class="hidden">3</div>
<div id="finish-display" class="hidden">FINISH!</div>

<div id="hud" class="hud hidden">
    <div>Time: <span id="time-display">0.00</span>s</div>
    <div>Lap: <span id="lap-counter">0</span>/3</div>
    <div style="color: #00d2d3; font-size: 18px; margin-top: 5px;">Pos: <span id="position-display">1st</span></div>
</div>

<div id="ui-layer">
    <h1>Select 3D Vehicle</h1>
    <div class="grid" id="car-select">
        <div class="card selected" data-car="0">
            <h3 style="color: #ff4757;">Sports Car</h3>
            <p>Fast & Drifty</p>
        </div>
        <div class="card" data-car="1">
            <h3 style="color: #2ed573;">SUV</h3>
            <p>Balanced</p>
        </div>
        <div class="card" data-car="2">
            <h3 style="color: #ffa502;">Truck</h3>
            <p>Heavy & Steady</p>
        </div>
    </div>
    <button id="start-btn">START RACE</button>
    <p class="controls">Controls: WASD or Arrows | Sound activates on Start!</p>
</div>

<div id="results-layer" class="hidden">
    <div class="results-box">
        <h2>RACE RESULTS</h2>
        <table id="results-table">
            <thead>
                <tr>
                    <th>Pos</th>
                    <th>Racer</th>
                    <th>Time</th>
                </tr>
            </thead>
            <tbody id="results-body"></tbody>
        </table>
        <button id="menu-btn">RETURN TO MENU</button>
    </div>
</div>

<script>
// --- AUDIO SYSTEM (Procedural Synthesis) ---
class AudioManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.engineOsc = null;
        this.engineGain = null;
    }

    init() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        this.startEngine();
    }

    playTone(freq, type, duration, vol=0.1) {
        let osc = this.ctx.createOscillator();
        let gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    startEngine() {
        if(this.engineOsc) return;
        this.engineOsc = this.ctx.createOscillator();
        this.engineOsc.type = 'sawtooth';
        
        this.engineGain = this.ctx.createGain();
        this.engineGain.gain.value = 0.05; // Low volume rumble
        
        let filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 300; // Muffle the harsh sawtooth

        this.engineOsc.connect(filter);
        filter.connect(this.engineGain);
        this.engineGain.connect(this.ctx.destination);
        this.engineOsc.start();
    }

    updateEngine(speed, maxSpeed) {
        if(!this.engineOsc) return;
        // Pitch mapping: 40Hz idle, scales up as you drive faster
        let pitch = 40 + (Math.abs(speed) / maxSpeed) * 120;
        this.engineOsc.frequency.setTargetAtTime(pitch, this.ctx.currentTime, 0.1);
    }

    stopEngine() {
        if(this.engineGain) {
            this.engineGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
            setTimeout(() => {
                if(this.engineOsc) { this.engineOsc.stop(); this.engineOsc = null; }
            }, 1000);
        }
    }

    playBoost() {
        let osc = this.ctx.createOscillator();
        let gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(300, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1200, this.ctx.currentTime + 0.3); // Quick upward pitch sweep
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + 0.8);
    }

    playFinish() {
        // Little victory melody
        this.playTone(523.25, 'square', 0.2, 0.05); // C5
        setTimeout(() => this.playTone(659.25, 'square', 0.2, 0.05), 150); // E5
        setTimeout(() => this.playTone(783.99, 'square', 0.4, 0.05), 300); // G5
        setTimeout(() => this.playTone(1046.50, 'square', 0.6, 0.05), 500); // C6
    }
}

// --- CONFIGURATION ---
const CAR_CONFIGS = [
    { name: "Sports Car", color: 0xff4757, maxSpeed: 2.2, accel: 0.05, handling: 0.04, size: {w: 2, h: 0.5, l: 4} },
    { name: "SUV", color: 0x2ed573, maxSpeed: 1.6, accel: 0.04, handling: 0.05, size: {w: 2.2, h: 1.2, l: 4.5} },
    { name: "Truck", color: 0xffa502, maxSpeed: 1.3, accel: 0.03, handling: 0.03, size: {w: 2.5, h: 1.5, l: 5.5} }
];
const AI_NAMES = ["Blue Comet", "Purple Phantom", "Orange Thunder"];
const AI_COLORS = [0x3498db, 0x9b59b6, 0xe67e22]; 

class InputManager {
    constructor() {
        this.keys = {};
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => this.keys[e.code] = false);
    }
    isPressed(codes) { return codes.some(code => this.keys[code]); }
}

class Car3D {
    constructor(scene, config, x, z, isAI = false, aiColor = null, name = "Player") {
        this.config = config;
        this.name = name;
        this.mesh = new THREE.Group();
        this.mesh.position.set(x, 1, z);
        
        this.speed = 0;
        this.angle = 0;
        this.friction = 0.95;
        this.isAI = isAI;
        this.boostTimer = 0;
        
        this.laps = 0;
        this.currentCheckpoint = 0;
        this.finished = false;
        this.finishTime = 0;

        this.buildModel(aiColor || this.config.color);
        scene.add(this.mesh);
    }

    buildModel(carColor) {
        const { w, h, l } = this.config.size;

        const chassisGeo = new THREE.BoxGeometry(w, h, l);
        const chassisMat = new THREE.MeshLambertMaterial({ color: carColor });
        this.chassis = new THREE.Mesh(chassisGeo, chassisMat);
        this.chassis.position.y = h / 2;
        this.chassis.castShadow = true;
        this.mesh.add(this.chassis);

        const cabinGeo = new THREE.BoxGeometry(w * 0.8, h * 0.8, l * 0.5);
        const cabinMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
        this.cabin = new THREE.Mesh(cabinGeo, cabinMat);
        this.cabin.position.set(0, h + (h*0.4), -l * 0.1);
        this.cabin.castShadow = true;
        this.mesh.add(this.cabin);

        const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
        wheelGeo.rotateZ(Math.PI / 2);
        const wheelMat = new THREE.MeshLambertMaterial({ color: 0x222222 });

        const wheelPositions = [
            { pos: [-w/2 - 0.2, 0.5, l/2 - 0.8], front: true },
            { pos: [ w/2 + 0.2, 0.5, l/2 - 0.8], front: true },
            { pos: [-w/2 - 0.2, 0.5, -l/2 + 0.8], front: false },
            { pos: [ w/2 + 0.2, 0.5, -l/2 + 0.8], front: false } 
        ];

        this.wheels = [];
        wheelPositions.forEach(data => {
            const group = new THREE.Group();
            group.position.set(...data.pos);
            const wheelMesh = new THREE.Mesh(wheelGeo, wheelMat);
            wheelMesh.castShadow = true;
            group.add(wheelMesh);
            this.mesh.add(group);
            this.wheels.push({ group: group, mesh: wheelMesh, isFront: data.front });
        });
    }

    update(input, canDrive) {
        let turnDir = 0;
        let currentMaxSpeed = this.config.maxSpeed;

        if (this.boostTimer > 0) {
            this.boostTimer--;
            this.speed += 0.08; 
            currentMaxSpeed *= 1.6; 
            if (!this.isAI) document.getElementById('speed-lines').classList.add('boosting');
        } else {
            if (!this.isAI) document.getElementById('speed-lines').classList.remove('boosting');
        }

        if (canDrive && !this.finished) {
            if (!this.isAI) {
                if (input.isPressed(['ArrowUp', 'KeyW'])) this.speed += this.config.accel;
                if (input.isPressed(['ArrowDown', 'KeyS'])) this.speed -= this.config.accel;
                if (input.isPressed(['Space'])) this.speed *= 0.8; 

                if (Math.abs(this.speed) > 0.1) {
                    turnDir = this.speed > 0 ? 1 : -1;
                    if (input.isPressed(['ArrowLeft', 'KeyA'])) { this.angle += this.config.handling * turnDir; turnDir = 1; }
                    else if (input.isPressed(['ArrowRight', 'KeyD'])) { this.angle -= this.config.handling * turnDir; turnDir = -1; }
                    else turnDir = 0;
                }
            } else {
                turnDir = this.lastAiTurnDir || 0; 
            }
        }

        this.speed = Math.max(-currentMaxSpeed / 2, Math.min(currentMaxSpeed, this.speed));
        
        if (!this.finished && canDrive) this.speed *= this.friction;
        else if (this.finished) this.speed *= 0.98; 

        this.mesh.rotation.y = this.angle;
        this.mesh.position.x += Math.sin(this.angle) * this.speed;
        this.mesh.position.z += Math.cos(this.angle) * this.speed;

        this.chassis.rotation.z = turnDir * (this.speed / currentMaxSpeed) * 0.1;
        this.cabin.rotation.z = turnDir * (this.speed / currentMaxSpeed) * 0.1;

        this.wheels.forEach(w => {
            w.mesh.rotation.x -= this.speed * 0.5; 
            if (w.isFront && !this.finished) w.group.rotation.y = turnDir * 0.5; 
            else if (this.finished) w.group.rotation.y = 0; 
        });
    }
}

class AICar3D extends Car3D {
    constructor(scene, config, x, z, color, name, waypoints) {
        super(scene, config, x, z, true, color, name);
        this.waypoints = waypoints;
        this.currentWaypoint = 0;
        this.aiMaxSpeed = config.maxSpeed * (0.85 + Math.random() * 0.2); 
        this.laneOffset = (Math.random() - 0.5) * 16; 
    }

    updateAI(canDrive) {
        if (!canDrive || this.finished || this.waypoints.length === 0) return;

        let baseTarget = this.waypoints[this.currentWaypoint];
        let targetX = baseTarget.x;
        let targetZ = baseTarget.z;
        if (baseTarget.z === 0) targetX += this.laneOffset; 
        if (baseTarget.x === 0) targetZ += this.laneOffset; 
        
        let dx = targetX - this.mesh.position.x;
        let dz = targetZ - this.mesh.position.z;
        
        if (Math.sqrt(dx*dx + dz*dz) < 30) {
            this.currentWaypoint = (this.currentWaypoint + 1) % this.waypoints.length;
        }

        let targetAngle = Math.atan2(dx, dz);
        let angleDiff = targetAngle - this.angle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

        this.angle += angleDiff * 0.08; 
        this.lastAiTurnDir = angleDiff > 0.1 ? 1 : (angleDiff < -0.1 ? -1 : 0);

        this.speed += this.config.accel * 0.9; 
        this.speed = Math.min(this.aiMaxSpeed, this.speed);
    }
}

class Environment {
    constructor(scene) {
        this.scene = scene;
        this.checkpoints = [];
        this.waypoints = [];
        this.boosts = [];
        
        this.scene.fog = new THREE.FogExp2(0x87ceeb, 0.004);

        this.buildTrack();
        this.buildDetails();
        this.buildForest();
        this.generateWaypoints();
        this.buildItems();
    }

    buildTrack() {
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshLambertMaterial({ color: 0x3d8c40 }));
        ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true; this.scene.add(ground);

        const trackMat = new THREE.MeshLambertMaterial({ color: 0x34495e });
        const s1 = new THREE.Mesh(new THREE.PlaneGeometry(40, 200), trackMat);
        s1.rotation.x = -Math.PI/2; s1.position.set(-80, 0.1, 0); s1.receiveShadow = true; this.scene.add(s1);

        const s2 = new THREE.Mesh(new THREE.PlaneGeometry(40, 200), trackMat);
        s2.rotation.x = -Math.PI/2; s2.position.set(80, 0.1, 0); s2.receiveShadow = true; this.scene.add(s2);

        const c1 = new THREE.Mesh(new THREE.RingGeometry(60, 100, 32, 1, 0, Math.PI), trackMat);
        c1.rotation.x = -Math.PI/2; c1.position.set(0, 0.1, -100); c1.receiveShadow = true; this.scene.add(c1);

        const c2 = new THREE.Mesh(new THREE.RingGeometry(60, 100, 32, 1, 0, Math.PI), trackMat);
        c2.rotation.x = -Math.PI/2; c2.rotation.z = Math.PI; c2.position.set(0, 0.1, 100); c2.receiveShadow = true; this.scene.add(c2);

        this.checkpoints = [
            { x: -80, z: 0, r: 45 }, { x: 0, z: -140, r: 45 },
            { x: 80, z: 0, r: 45 }, { x: 0, z: 140, r: 45 }
        ];

        const wallMatRed = new THREE.MeshLambertMaterial({ color: 0xe74c3c });
        const wallMatWhite = new THREE.MeshLambertMaterial({ color: 0xecf0f1 });
        
        const createWall = (x, z) => {
            const wGroup = new THREE.Group();
            for(let i=0; i<10; i++) {
                let colorMat = i % 2 === 0 ? wallMatRed : wallMatWhite;
                let block = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 20), colorMat);
                block.position.set(x, 1, z - 90 + (i * 20));
                block.castShadow = true;
                wGroup.add(block);
            }
            this.scene.add(wGroup);
        };
        createWall(-100, 0); createWall(-60, 0); createWall(100, 0); createWall(60, 0);
    }

    buildDetails() {
        const gridGroup = new THREE.Group();
        const whiteSquareMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const greySquareMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
        
        for(let r=0; r<3; r++) {
            for(let c=0; c<10; c++) {
                let isWhite = (r + c) % 2 === 0;
                let sq = new THREE.Mesh(new THREE.PlaneGeometry(2, 4), isWhite ? whiteSquareMat : greySquareMat);
                sq.rotation.x = -Math.PI/2;
                sq.position.set(-62 - (c * 4), 0.15, -5 + (r * 2)); 
                gridGroup.add(sq);
            }
        }
        this.scene.add(gridGroup);
    }

    buildForest() {
        const trunkGeo = new THREE.CylinderGeometry(0.8, 1, 4, 8);
        const trunkMat = new THREE.MeshLambertMaterial({ color: 0x5c4033 });
        const leavesGeo = new THREE.ConeGeometry(3.5, 12, 8);
        const leavesMat = new THREE.MeshLambertMaterial({ color: 0x27ae60 });

        for (let i = 0; i < 200; i++) {
            let x = (Math.random() - 0.5) * 500;
            let z = (Math.random() - 0.5) * 500;
            if (x > -120 && x < 120 && z > -220 && z < 220) continue;

            let tree = new THREE.Group();
            let trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 2; trunk.castShadow = true;
            let leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 8; leaves.castShadow = true;
            
            tree.add(trunk); tree.add(leaves);
            tree.position.set(x, 0, z);
            
            let scale = 0.8 + Math.random() * 0.6;
            tree.scale.set(scale, scale, scale);
            this.scene.add(tree);
        }
    }

    buildItems() {
        const outerMat = new THREE.MeshLambertMaterial({ color: 0x00ffff, emissive: 0x00aaff, transparent: true, opacity: 0.6 });
        const innerMat = new THREE.MeshLambertMaterial({ color: 0xffffff, emissive: 0xffffff });
        const outerGeo = new THREE.OctahedronGeometry(3);
        const innerGeo = new THREE.OctahedronGeometry(1.5);

        let locations = [ [-80, -50], [80, 50], [0, 180], [0, -180] ];
        
        locations.forEach(pos => {
            let group = new THREE.Group();
            group.position.set(pos[0], 3.5, pos[1]); 
            let outer = new THREE.Mesh(outerGeo, outerMat);
            let inner = new THREE.Mesh(innerGeo, innerMat);
            group.add(outer); group.add(inner);
            this.scene.add(group);
            this.boosts.push({ group: group, outer: outer, inner: inner }); 
        });
    }

    generateWaypoints() {
        for (let z = 0; z >= -100; z -= 25) this.waypoints.push({x: -80, z: z});
        for (let a = Math.PI; a > 0; a -= Math.PI/6) this.waypoints.push({x: 80 * Math.cos(a), z: -100 - 80 * Math.sin(a)});
        for (let z = -100; z <= 100; z += 25) this.waypoints.push({x: 80, z: z});
        for (let a = 0; a > -Math.PI; a -= Math.PI/6) this.waypoints.push({x: 80 * Math.cos(a), z: 100 - 80 * Math.sin(a)});
    }
}

class Game3DEngine {
    constructor() {
        this.container = document.getElementById('game-container');
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x87ceeb); 
        
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        this.container.appendChild(this.renderer.domElement);

        this.scene.add(new THREE.AmbientLight(0xffffff, 0.7)); 
        const dirLight = new THREE.DirectionalLight(0xfffff0, 0.8); 
        dirLight.position.set(150, 250, 50); dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048; 
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.top = 250; dirLight.shadow.camera.bottom = -250;
        dirLight.shadow.camera.left = -250; dirLight.shadow.camera.right = 250;
        this.scene.add(dirLight);

        this.input = new InputManager();
        this.audio = new AudioManager(); // Initiate Audio System
        
        this.maxLaps = 3;
        this.reqFrame = null;
        this.canDrive = false; 
        this.orbitAngle = 0; 
        
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
    }

    start(carIndex) {
        if (this.reqFrame) cancelAnimationFrame(this.reqFrame);
        
        // This MUST be called on button click to appease browser autoplay policies
        this.audio.init(); 
        
        while(this.scene.children.length > 2) this.scene.remove(this.scene.children[2]); 
        
        this.environment = new Environment(this.scene);
        
        this.car = new Car3D(this.scene, CAR_CONFIGS[carIndex], -80, 10, false, null, "You (Player)");
        this.car.angle = Math.PI; 
        
        this.aiCars = [];
        for (let i = 0; i < 3; i++) {
            let aiConfig = CAR_CONFIGS[Math.floor(Math.random() * CAR_CONFIGS.length)];
            let aiX = -72 + (Math.random() * 10 - 5); 
            let aiZ = 20 + (i * 12); 
            let ai = new AICar3D(this.scene, aiConfig, aiX, aiZ, AI_COLORS[i], AI_NAMES[i], this.environment.waypoints);
            ai.angle = Math.PI;
            this.aiCars.push(ai);
        }
        
        document.getElementById('lap-counter').innerText = "0";
        document.getElementById('time-display').innerText = "0.00";
        document.getElementById('finish-display').classList.add('hidden');
        document.getElementById('results-layer').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        
        this.isRunning = true;
        this.canDrive = false;
        this.orbitAngle = Math.PI; 
        
        this.updateCamera(); 
        this.runCountdown(); 
        this.loop();
    }

    runCountdown() {
        let count = 3;
        let cdElem = document.getElementById('countdown-display');
        
        cdElem.innerText = count;
        cdElem.style.color = "#ffeb3b";
        cdElem.classList.remove('hidden');
        cdElem.classList.add('pop');
        this.audio.playTone(440, 'sine', 0.1, 0.1); // Beep!
        
        let interval = setInterval(() => {
            cdElem.classList.remove('pop'); 
            void cdElem.offsetWidth; 
            
            count--;
            
            if (count > 0) {
                cdElem.innerText = count;
                cdElem.classList.add('pop');
                this.audio.playTone(440, 'sine', 0.1, 0.1); // Beep!
            } else if (count === 0) {
                cdElem.innerText = "GO!";
                cdElem.style.color = "#2ed573";
                cdElem.classList.add('pop');
                this.audio.playTone(880, 'sine', 0.3, 0.15); // High Beep!
                
                this.canDrive = true;
                this.startTime = Date.now();
            } else {
                cdElem.classList.add('hidden');
                clearInterval(interval);
            }
        }, 1000);
    }

    keepCarOnTrack(carObj) {
        let pos = carObj.mesh.position;
        let trackCenterDist = 0; let pushX = 0; let pushZ = 0;

        if (pos.z > -100 && pos.z < 100) {
            trackCenterDist = Math.abs(pos.x - (pos.x < 0 ? -80 : 80));
            pushX = pos.x > (pos.x < 0 ? -80 : 80) ? -1 : 1;
        } else {
            let centerY = pos.z <= -100 ? -100 : 100;
            let distToCenter = Math.sqrt(pos.x*pos.x + (pos.z - centerY)*(pos.z - centerY));
            trackCenterDist = Math.abs(distToCenter - 80);
            pushX = (0 - pos.x) / distToCenter; pushZ = (centerY - pos.z) / distToCenter;
            if (distToCenter < 80) { pushX *= -1; pushZ *= -1; }
        }

        if (trackCenterDist > 18) {
            carObj.mesh.position.x += pushX * 0.5; carObj.mesh.position.z += pushZ * 0.5;
            carObj.speed *= 0.8; 
        }
    }

    checkItems() {
        this.environment.boosts.forEach(b => {
            b.outer.rotation.y += 0.02; b.outer.rotation.x += 0.01;
            b.inner.rotation.y -= 0.04; b.inner.rotation.x -= 0.02;

            [this.car, ...this.aiCars].forEach(car => {
                if (car.finished) return;
                let dx = car.mesh.position.x - b.group.position.x;
                let dz = car.mesh.position.z - b.group.position.z;
                
                if (Math.sqrt(dx*dx + dz*dz) < 10.0 && car.boostTimer < 110) {
                    car.boostTimer = 120; 
                    if (car === this.car) this.audio.playBoost(); // Play sound if Player gets it
                }
            });
        });
    }

    checkLaps(carObj) {
        if (carObj.finished) return;
        
        let cp = this.environment.checkpoints[carObj.currentCheckpoint];
        let dx = carObj.mesh.position.x - cp.x;
        let dz = carObj.mesh.position.z - cp.z;
        
        if (Math.sqrt(dx*dx + dz*dz) < cp.r) {
            carObj.currentCheckpoint++;
            
            if (carObj.currentCheckpoint >= this.environment.checkpoints.length) {
                carObj.currentCheckpoint = 0;
                carObj.laps++;
                
                if (carObj === this.car) {
                    document.getElementById('lap-counter').innerText = carObj.laps;
                }
                
                if (carObj.laps >= this.maxLaps) {
                    carObj.finished = true;
                    carObj.finishTime = ((Date.now() - this.startTime) / 1000).toFixed(2);
                    
                    if (carObj === this.car) {
                        this.triggerPlayerFinish();
                    }
                }
            }
        }
    }

    updateCamera() {
        if (this.car.finished) {
            this.orbitAngle += 0.01;
            const radius = 20;
            const cx = this.car.mesh.position.x + Math.sin(this.orbitAngle) * radius;
            const cz = this.car.mesh.position.z + Math.cos(this.orbitAngle) * radius;
            
            const targetPos = new THREE.Vector3(cx, this.car.mesh.position.y + 6, cz);
            this.camera.position.lerp(targetPos, 0.05);
            this.camera.lookAt(this.car.mesh.position);
        } else {
            const relativeCameraOffset = new THREE.Vector3(0, 10, -22); 
            const cameraOffset = relativeCameraOffset.applyMatrix4(this.car.mesh.matrixWorld);
            this.camera.position.lerp(cameraOffset, 0.1);
            
            const lookAtPos = this.car.mesh.position.clone();
            lookAtPos.y += 2; 
            this.camera.lookAt(lookAtPos);
        }
    }

    calculatePositions() {
        let allCars = [this.car, ...this.aiCars];
        allCars.sort((a, b) => {
            if (a.finished && b.finished) return a.finishTime - b.finishTime;
            if (a.finished) return -1;
            if (b.finished) return 1;
            let scoreA = (a.laps * 10) + a.currentCheckpoint;
            let scoreB = (b.laps * 10) + b.currentCheckpoint;
            return scoreB - scoreA; 
        });
        return allCars;
    }

    triggerPlayerFinish() {
        let finElem = document.getElementById('finish-display');
        finElem.classList.remove('hidden');
        finElem.classList.add('pop');
        
        this.audio.playFinish(); // Play Victory Jingle
        this.audio.stopEngine(); // Shut off the rumble
        
        setTimeout(() => finElem.classList.add('hidden'), 2000);
        setTimeout(() => this.showResultsScreen(), 3000);
    }

    showResultsScreen() {
        document.getElementById('hud').classList.add('hidden');
        let resultsLayer = document.getElementById('results-layer');
        let tableBody = document.getElementById('results-body');
        
        tableBody.innerHTML = ''; 
        let standings = this.calculatePositions();
        
        standings.forEach((racer, index) => {
            let tr = document.createElement('tr');
            if (racer === this.car) tr.classList.add('player-row');
            let timeStr = racer.finished ? racer.finishTime + "s" : "DNF (Still Racing)";
            
            tr.innerHTML = `
                <td>${index + 1}</td>
                <td>${racer.name}</td>
                <td>${timeStr}</td>
            `;
            tableBody.appendChild(tr);
        });
        
        resultsLayer.classList.remove('hidden');
    }

    stopGame() {
        this.isRunning = false;
        this.audio.stopEngine();
        if (this.reqFrame) cancelAnimationFrame(this.reqFrame);
        document.getElementById('results-layer').classList.add('hidden');
        document.getElementById('ui-layer').classList.remove('hidden');
    }

    loop() {
        if (!this.isRunning) return;

        if (this.canDrive && !this.car.finished) {
            let currentTimer = (Date.now() - this.startTime) / 1000;
            document.getElementById('time-display').innerText = currentTimer.toFixed(2);
            
            let currentStandings = this.calculatePositions();
            let playerRank = currentStandings.indexOf(this.car) + 1;
            let suffix = ["th","st","nd","rd"][playerRank > 3 ? 0 : playerRank];
            document.getElementById('position-display').innerText = playerRank + suffix;
            
            // Mathematically update engine sound pitch based on speed
            this.audio.updateEngine(this.car.speed, this.car.config.maxSpeed * 1.6);
        }

        this.car.update(this.input, this.canDrive);
        this.keepCarOnTrack(this.car);
        if (this.canDrive) this.checkLaps(this.car, true);

        this.aiCars.forEach(ai => {
            ai.updateAI(this.canDrive);
            ai.update(this.input, this.canDrive); 
            this.keepCarOnTrack(ai); 
            if (this.canDrive) this.checkLaps(ai, false);
        });

        this.checkItems();
        this.updateCamera();

        this.renderer.render(this.scene, this.camera);
        this.reqFrame = requestAnimationFrame(() => this.loop());
    }
}

const game = new Game3DEngine();
let selectedCar = 0;

document.querySelectorAll('#car-select .card').forEach(card => {
    card.addEventListener('click', () => {
        document.querySelectorAll('#car-select .card').forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        selectedCar = parseInt(card.dataset.car);
    });
});

document.getElementById('start-btn').addEventListener('click', () => {
    document.getElementById('ui-layer').classList.add('hidden');
    game.start(selectedCar);
});

document.getElementById('menu-btn').addEventListener('click', () => {
    game.stopGame();
});

</script>
</body>
</html>